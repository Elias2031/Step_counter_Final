'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resignIPA = exports.createEntitlementsFile = exports.resolveExportMethod = exports.buildIPA = exports.writeExportOptionsPlistFile = exports.ensureCertificateValid = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let ensureCertificateValid = exports.ensureCertificateValid = (() => {
  var _ref = _asyncToGenerator(function* ({ certPath, certPassword, teamID }) {
    const certData = yield (_fsExtra || _load_fsExtra()).default.readFile(certPath);
    const fingerprint = genCertFingerprint(certData, certPassword);
    const identities = yield findIdentitiesByTeamID(teamID);
    const isValid = identities.indexOf(fingerprint) !== -1;
    if (!isValid) {
      throw new Error(`codesign ident not present in find-identity: ${fingerprint}\n${identities}`);
    }
    return fingerprint;
  });

  return function ensureCertificateValid(_x) {
    return _ref.apply(this, arguments);
  };
})();

let findIdentitiesByTeamID = (() => {
  var _ref2 = _asyncToGenerator(function* (teamID) {
    const { output } = yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('security', ['find-identity', '-v', '-s', `(${teamID})`], {
      stdio: 'pipe'
    });
    return output.join('');
  });

  return function findIdentitiesByTeamID(_x2) {
    return _ref2.apply(this, arguments);
  };
})();

let writeExportOptionsPlistFile = exports.writeExportOptionsPlistFile = (() => {
  var _ref3 = _asyncToGenerator(function* (plistPath, data) {
    const toWrite = createExportOptionsPlist(data);
    yield (_fsExtra || _load_fsExtra()).default.writeFile(plistPath, toWrite);
  });

  return function writeExportOptionsPlistFile(_x3, _x4) {
    return _ref3.apply(this, arguments);
  };
})();

let buildIPA = exports.buildIPA = (() => {
  var _ref4 = _asyncToGenerator(function* ({
    ipaPath,
    workspace,
    archivePath,
    codeSignIdentity,
    exportOptionsPlistPath,
    plistData,
    keychainPath,
    exportMethod
  }, credentials, client = false) {
    if (client) {
      yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('xcodebuild', ['-exportArchive', '-archivePath', archivePath, '-exportOptionsPlist', exportOptionsPlistPath, '-exportPath', _path.default.Dir(ipaPath), `OTHER_CODE_SIGN_FLAGS="--keychain ${keychainPath}"`], {
        env: _extends({}, process.env, { CI: 1 })
      });
    } else {
      yield runFastlane(credentials, ['gym', '-n', _path.default.basename(ipaPath), '--workspace', workspace, '--scheme', 'ExpoKitApp', '--archive_path', archivePath, '--skip_build_archive', 'true', '-i', codeSignIdentity, '--export_options', exportOptionsPlistPath, '--export_method', exportMethod, '--export_xcargs', `OTHER_CODE_SIGN_FLAGS="--keychain ${keychainPath}"`, '-o', _path.default.dirname(ipaPath), '--verbose']);
    }
  });

  return function buildIPA(_x5, _x6) {
    return _ref4.apply(this, arguments);
  };
})();

let createEntitlementsFile = exports.createEntitlementsFile = (() => {
  var _ref5 = _asyncToGenerator(function* ({
    generatedEntitlementsPath,
    plistData,
    archivePath
  }) {
    const decodedProvisioningProfileEntitlements = plistData.Entitlements;

    const entitlementsPattern = _path.default.join(archivePath, 'Products/Applications/ExpoKitApp.app/*.entitlements');
    const entitlementsPaths = yield (0, (_globPromise || _load_globPromise()).default)(entitlementsPattern);
    if (entitlementsPaths.length === 0) {
      throw new Error("Didn't find any generated entitlements file in archive.");
    } else if (entitlementsPaths.length !== 1) {
      throw new Error('Found more than one entitlements file.');
    }
    const archiveEntitlementsPath = entitlementsPaths[0];
    const archiveEntitlementsRaw = yield (_fsExtra || _load_fsExtra()).default.readFile(archiveEntitlementsPath);
    const archiveEntitlementsData = (_lodash || _load_lodash()).default.attempt((_plist || _load_plist()).default.parse, String(archiveEntitlementsRaw));
    if ((_lodash || _load_lodash()).default.isError(archiveEntitlementsData)) {
      throw new Error(`Error when parsing plist: ${archiveEntitlementsData.message}`);
    }

    const entitlements = _extends({}, decodedProvisioningProfileEntitlements);
    entitlementTransferRules.forEach(function (rule) {
      if (rule in archiveEntitlementsData) {
        entitlements[rule] = archiveEntitlementsData[rule];
      }
    });
    const generatedEntitlements = (_lodash || _load_lodash()).default.pickBy(entitlements, function (val, key) {
      return !(_lodash || _load_lodash()).default.includes(blacklistedEntitlementKeys, key);
    });
    const generatedEntitlementsPlistData = (_lodash || _load_lodash()).default.attempt((_plist || _load_plist()).default.build, generatedEntitlements);
    yield (_fsExtra || _load_fsExtra()).default.writeFile(generatedEntitlementsPath, generatedEntitlementsPlistData, {
      mode: 0o755
    });
    const { output } = yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/usr/libexec/PlistBuddy', ['-x', '-c', 'Print', generatedEntitlementsPath], {
      stdio: 'pipe'
    });
    const plistDataReformatted = output.join('');
    yield (_fsExtra || _load_fsExtra()).default.writeFile(generatedEntitlementsPath, plistDataReformatted, {
      mode: 0o755
    });
  });

  return function createEntitlementsFile(_x7) {
    return _ref5.apply(this, arguments);
  };
})();

let resignIPA = exports.resignIPA = (() => {
  var _ref6 = _asyncToGenerator(function* ({
    codeSignIdentity,
    entitlementsPath,
    provisioningProfilePath,
    sourceIpaPath,
    destIpaPath,
    keychainPath
  }, credentials) {
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('cp', ['-rf', sourceIpaPath, destIpaPath]);
    yield runFastlane(credentials, ['sigh', 'resign', '--verbose', '--entitlements', entitlementsPath, '--signing_identity', codeSignIdentity, '--keychain_path', keychainPath, '--provisioning_profile', provisioningProfilePath, destIpaPath]);
  });

  return function resignIPA(_x8, _x9) {
    return _ref6.apply(this, arguments);
  };
})();

let runFastlane = (() => {
  var _ref7 = _asyncToGenerator(function* ({ teamID, password }, fastlaneArgs) {
    const fastlaneEnvVars = {
      FASTLANE_SKIP_UPDATE_CHECK: 1,
      FASTLANE_DISABLE_COLORS: 1,
      FASTLANE_TEAM_ID: teamID,
      FASTLANE_PASSWORD: password,
      CI: 1
    };

    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('fastlane', fastlaneArgs, {
      env: _extends({}, process.env, fastlaneEnvVars)
    });
  });

  return function runFastlane(_x10, _x11) {
    return _ref7.apply(this, arguments);
  };
})();

var _nodeForge;

function _load_nodeForge() {
  return _nodeForge = _interopRequireDefault(require('node-forge'));
}

var _lodash;

function _load_lodash() {
  return _lodash = _interopRequireDefault(require('lodash'));
}

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _path = _interopRequireDefault(require('path'));

var _globPromise;

function _load_globPromise() {
  return _globPromise = _interopRequireDefault(require('glob-promise'));
}

var _plist;

function _load_plist() {
  return _plist = _interopRequireDefault(require('plist'));
}

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = require('./ExponentTools');
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function genCertFingerprint(p12Buffer, password) {
  if (Buffer.isBuffer(p12Buffer)) {
    p12Buffer = p12Buffer.toString('base64');
  } else if (typeof p12Buffer !== 'string') {
    throw new Error('genCertFingerprint only takes strings and buffers.');
  }

  const certBagType = (_nodeForge || _load_nodeForge()).default.pki.oids.certBag;

  const p12Der = (_nodeForge || _load_nodeForge()).default.util.decode64(p12Buffer);
  const p12Asn1 = (_nodeForge || _load_nodeForge()).default.asn1.fromDer(p12Der);
  const p12 = (_nodeForge || _load_nodeForge()).default.pkcs12.pkcs12FromAsn1(p12Asn1, password || '');
  const certData = (_lodash || _load_lodash()).default.get(p12.getBags({ bagType: certBagType }), [certBagType, 0, 'cert']);
  if (!certData) {
    throw new Error("genCertFingerprint: couldn't find cert bag");
  }
  const certAsn1 = (_nodeForge || _load_nodeForge()).default.pki.certificateToAsn1(certData);
  const certDer = (_nodeForge || _load_nodeForge()).default.asn1.toDer(certAsn1).getBytes();
  return (_nodeForge || _load_nodeForge()).default.md.sha1.create().update(certDer).digest().toHex().toUpperCase();
}

const createExportOptionsPlist = ({
  bundleIdentifier,
  provisioningProfileUUID,
  exportMethod,
  teamID
}) => `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>method</key>
    <string>${exportMethod}</string>
    <key>teamID</key>
    <string>${teamID}</string>
    <key>provisioningProfiles</key>
    <dict>
      <key>${bundleIdentifier}</key>
      <string>${provisioningProfileUUID}</string>
    </dict>
  </dict>
</plist>`;

const resolveExportMethod = exports.resolveExportMethod = plistData => {
  if (plistData.ProvisionedDevices) {
    return 'ad-hoc';
  } else if (plistData.ProvisionsAllDevices === true) {
    return 'enterprise';
  } else {
    return 'app-store';
  }
};

const entitlementTransferRules = ['com.apple.developer.associated-domains', 'com.apple.developer.healthkit', 'com.apple.developer.homekit', 'com.apple.developer.icloud-container-identifiers', 'com.apple.developer.icloud-services', 'com.apple.developer.in-app-payments', 'com.apple.developer.networking.vpn.api', 'com.apple.developer.ubiquity-container-identifiers', 'com.apple.developer.ubiquity-kvstore-identifier', 'com.apple.external-accessory.wireless-configuration', 'com.apple.security.application-groups', 'inter-app-audio', 'keychain-access-groups'];

const blacklistedEntitlementKeys = ['com.apple.developer.icloud-container-development-container-identifiers', 'com.apple.developer.icloud-container-environment', 'com.apple.developer.icloud-container-identifiers', 'com.apple.developer.icloud-services', 'com.apple.developer.restricted-resource-mode', 'com.apple.developer.ubiquity-container-identifiers', 'com.apple.developer.ubiquity-kvstore-identifier', 'inter-app-audio', 'com.apple.developer.homekit', 'com.apple.developer.healthkit', 'com.apple.developer.in-app-payments', 'com.apple.developer.maps', 'com.apple.external-accessory.wireless-configuration'];
//# sourceMappingURL=../__sourcemaps__/detach/IosUtils.js.map
